{% extends "base.html" %}

{% block content %}
  <script>
    var img_data = {{ data|safe }}
    var log_count = 0;
    $(function(){
    setInterval(function(){
        $.ajax({
	        url : '/drawing/log',
	        type: 'GET',
	        data: {
	            'kind': 'ranking',
	        },
	        success : function(data)
	        {
		        if (data > log_count) {
		            if (log_count != 0) {
		                alert_login();
		            };
		            log_count = data;
		        };
	        },
	        error : function(data)
	        {
		        console.log(data);
	        },
	        complete : function(data)
	        {

	        }
        });
    },4000);
    });

    var alert_login = function() {
        toastr.options.timeOut = 2000; // 3秒
        toastr.options = {
        "closeButton": true,
        "debug": false,
        "newestOnTop": false,
        "progressBar": false,
        "positionClass": "toast-bottom-right",
        "preventDuplicates": false,
        "showDuration": "300",
        "hideDuration": "1000",
        "timeOut": "3000",
        "extendedTimeOut": "1000",
        "showEasing": "swing",
        "hideEasing": "linear",
        "showMethod": "fadeIn",
        "hideMethod": "fadeOut"
        };
        Command: toastr["info"]("新たにゲストが入場しました！");
        $('#linkButton').click(function() {
            toastr.success('click');
        });
    };


   var container, stats;

   var camera, scene, renderer;

   var mesh;

  var targetRotationX = 0;
  var targetRotationY = 0;
  var targetRotationXOnMouseDown = 0;
  var targetRotationYOnMouseDown = 0;

  var mouseX = 0;
   var mouseXOnMouseDown = 0;

  var mouseY = 0;
   var mouseYOnMouseDown = 0;

   var windowHalfX = window.innerWidth / 2;
   var windowHalfY = window.innerHeight / 2;

   var gyroDefaultX = 1.5
   var gyroDefaultY = 0

    var campo= true;

    var longtapX = 0;
    var longtapY = 0;

    var mouse = {
     x: 0,
     y: 0
   };

   var touch = {
    x: 0,
    y: 0
   };

   var container,
     scene,
     camera,
     renderer,
     plane,
     mouseMesh,
     light;

     var  meshm;

   init();
   animate();

   function init() {

     container = document.createElement( 'div' );
     document.body.appendChild( container );


     camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
     camera.position.y = 50;
     camera.position.z = 100;

     scene = new THREE.Scene();

     drawObject();

     renderer = new THREE.CanvasRenderer();
     renderer.setClearColor( 0x000000 );
     renderer.setPixelRatio( window.devicePixelRatio );
     renderer.setSize( window.innerWidth, window.innerHeight );
     container.appendChild( renderer.domElement );

     document.addEventListener( 'mousedown', onDocumentMouseDown, false );
     document.addEventListener( 'touchstart', onDocumentTouchStart, false );
     document.addEventListener( 'touchmove', onDocumentTouchMove, false );
     document.addEventListener( 'touchend', onDocumentTouchEnd, false );
     window.addEventListener( 'resize', onWindowResize, false );
   }

   function onWindowResize() {
     windowHalfX = window.innerWidth / 2;
     windowHalfY = window.innerHeight / 2;

     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();

     renderer.setSize( window.innerWidth, window.innerHeight );
   }

   function onDocumentMouseDown( event ) {

     event.preventDefault();

     document.addEventListener( 'mousemove', onDocumentMouseMove, false );
     document.addEventListener( 'mouseup', onDocumentMouseUp, false );
     document.addEventListener( 'mouseout', onDocumentMouseOut, false );

     mouseXOnMouseDown = event.clientX - windowHalfX;
     mouseYOnMouseDown = event.clientY - windowHalfY;
     targetRotationXOnMouseDown = targetRotationX;
     targetRotationYOnMouseDown = targetRotationY;

     var interval = 1000;
     longtapX = mouseXOnMouseDown
     longtapY = mouseYOnMouseDown
     timer = setTimeout(function(){
       if(campo==true){
           if(camera.position.z>50){
             camera.position.z-=250;
           } else {
             campo = false;
             camout()
           }
       } else if(campo==false){
         camout();
         console.log(camera.position.z);
       }
     }, interval);
   }

   function onDocumentMouseMove( event ) {
     mouseX = event.clientX - windowHalfX;
     mouseY  = event.clientY - windowHalfY;

     targetRotationX = targetRotationXOnMouseDown - ( mouseX - mouseXOnMouseDown ) * 0.005;
     targetRotationY = targetRotationYOnMouseDown - ( mouseY - mouseYOnMouseDown ) * 0.004;

     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

     var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
     vector.unproject(camera);
     var dir = vector.sub(camera.position).normalize();
     var distance = -camera.position.z / dir.z;
     var pos = camera.position.clone().add(dir.multiplyScalar(distance));

     meshm.position.copy(pos);

      if ((Math.abs(longtapX - mouseX) > 10) || (Math.abs(longtapY - mouseY) > 10)) {
        clearTimeout(timer);
      }
   }

   function onDocumentMouseUp( event ) {
     clearTimeout(timer);
     document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
     document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
     document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
   }

   function onDocumentMouseOut( event ) {
     clearTimeout(timer);
     document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
     document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
     document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
   }

   function onDeviceOrientationX(x) {
     var diffX = parseFloat(x) - gyroDefaultX
     gyroDefaultX = parseFloat(x)
     targetRotationX = targetRotationX - diffX*1.5
   }

   function onDeviceOrientationY(y) {
     var diffY = parseFloat(y) - gyroDefaultY
     gyroDefaultY = parseFloat(y)
     targetRotationY = targetRotationY + diffY*1.3
   }

   function onDocumentTouchStart( event ) {

     if ( event.touches.length === 1 ) {
       event.preventDefault();
       mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
       mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
       targetRotationXOnMouseDown = targetRotationX;
       targetRotationYOnMouseDown = targetRotationY;

       longtapX = mouseXOnMouseDown
       longtapY = mouseYOnMouseDown
        var interval = 1000;
        timer = setTimeout(function(){
          if(campo==true){
              if(camera.position.z>50){
                camera.position.z-=250;
              }
              else {
                campo = false;
                camout()
              }
          } else if(campo==false){
            camout();
            console.log(camera.position.z);
          }
        }, interval);
      }
   }

   function camout(){
     if(camera.position.z<50){
       camera.position.z+=250 ;
       console.log('going out')
     } else{
       campo=true;
     }
   }

   function onDocumentTouchMove( event ) {

    if ( event.touches.length === 1 ) {
      event.preventDefault();
      mouseX = event.touches[ 0 ].pageX - windowHalfX;
      mouseY = event.touches[ 0 ].pageY - windowHalfY;
      targetRotationX = targetRotationXOnMouseDown - ( mouseX - mouseXOnMouseDown ) * 0.005;
      targetRotationY = targetRotationYOnMouseDown - ( mouseY - mouseYOnMouseDown ) * 0.004;

      touch.x = (event.touches[ 0 ].pageX / window.innerWidth) * 2 - 1;
      touch.y = -(event.touches[ 0 ].pageY / window.innerHeight) * 2 + 1;


      var vector = new THREE.Vector3(touch.x, touch.y, 0.5);
      vector.unproject(camera);
      var dir = vector.sub(camera.position).normalize();
      var distance = -camera.position.z / dir.z;
      var pos = camera.position.clone().add(dir.multiplyScalar(distance));

      meshm.position.copy(pos);

      if ((Math.abs(longtapX - mouseX) > 10) || (Math.abs(longtapY - mouseY) > 10)) {
        clearTimeout(timer);
      }

    }
   }

   function onDocumentTouchEnd( event ) {
     clearTimeout(timer);
   }

   //

   function animate() {
     requestAnimationFrame( animate );
     render();
   }

   function render() {
     mesh.rotation.y += ( targetRotationX - mesh.rotation.y ) * 0.05;
     mesh.rotation.x += ( targetRotationY - mesh.rotation.x ) * 0.05;
     renderer.render( scene, camera );
   }

   //---------------------------------------------------------
   //  物体を作る
   //---------------------------------------------------------
   function drawObject()
   {
       var imgFile = [];
       for (var i = 0; i < 100; i++) {
           imgFile.push(img_data["image_urls"][i]);
       }

       var canv = document.createElement("canvas");
       canv.width = 4000;
       canv.height = 2000;

       var allnum = imgFile.length;
       var cnt = 0;
       var imgList = [];
       for(var i in imgFile)
       {
           imgList[i] = new Image();
           imgList[i].onload = function()
           {
               if (++cnt == allnum) //画像が全部揃ったらメッシュを作成
                   drawImage(canv, imgList);
           };
           imgList[i].onerror = function()
           {
               if (++cnt == allnum) //画像が全部揃ったらメッシュを作成
                   drawImage(canv, imgList);
           };
           imgList[i].src = imgFile[i];
       }
   }

   //---------------------------------------------------------
   //  カンバスに絵を描いて貼り付ける
   //---------------------------------------------------------
   function drawImage(canv, imgList)
   {
       var ctx = canv.getContext('2d');
       var n = 0;
       var m = 0;
       var ysiz = imgList[n].height;
       var xsiz = imgList[n].width;
       for(var y = 350; y < canv.height - 400; y += 210)
       {
           for(var x = 0; x < canv.width; x += 210)
           {
              var img = imgList[m % imgList.length];
              m += n + Math.round(50 * Math.random());
              n++;
              ctx.drawImage(img, x, y, xsiz*180/150, ysiz*180/150);
           }
       }

      //  // テクスチャを作成
        var tex = new THREE.Texture(canv);
        tex.needsUpdate = true;
       //
      //  //マテリアルとメッシュを作ってシーンに追加
        var geo = new THREE.SphereGeometry(400);
        geo.scale(-1,1,1);
      //  geo.position.y =  150;
    //    mat = new THREE.MeshPhongMaterial({color: 0xff0000});
        var mat = new THREE.MeshBasicMaterial({map: tex});
        mat.side = THREE.DoubleSide;
         mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);

        var geom=new THREE.SphereGeometry(5);
          var matm=new THREE.MeshBasicMaterial({
               side: THREE.FrontSide,
               color: 0x0099FF,
               ambient:0x990000,
               specular:0xffff00,
               shininess:30,
               metal:true
      });
          meshm=new THREE.Mesh(geom, matm);
          scene.add(meshm);
   }


  </script>
{% endblock content %}
